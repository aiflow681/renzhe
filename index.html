<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>忍者突袭 Pure H5</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        html {
            height: 100%;
        }

        body {
            overflow: hidden;
            background-color: #1d1d1d;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            touch-action: none;
            height: 100%;
            width: 100%;
            position: fixed; /* Prevents scroll bounce on mobile */
        }

        #canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        #top-hud {
            width: 100%;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        #lives-panel {
            display: flex;
            gap: 5px;
        }
        
        .heart {
            color: #ff1744;
            font-size: 24px;
            text-shadow: 0 0 5px rgba(255, 23, 68, 0.5);
        }

        #score-container {
            text-align: right;
        }

        #score {
            font-size: 36px;
            color: #fff;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        
        #best-score {
            font-size: 14px;
            color: #aaa;
            margin-top: 5px;
        }

        /* Controls */
        #controls {
            width: 100%;
            height: 160px; /* Fixed height for controls */
            display: flex;
            pointer-events: auto; /* Enable clicks */
            position: absolute;
            bottom: 0;
            left: 0;
            padding-bottom: env(safe-area-inset-bottom, 20px);
        }

        .control-zone {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            border-top: 1px solid rgba(255,255,255,0.1);
            background: rgba(0,0,0,0.2);
            position: relative;
        }
        
        .control-zone:active {
            background: rgba(255,255,255,0.05); /* Visual feedback */
        }

        .control-label {
            font-size: 24px;
            color: rgba(255,255,255,0.5);
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            pointer-events: none;
        }
        
        .control-divider {
            width: 1px;
            height: 60%;
            background: rgba(255,255,255,0.1);
            position: absolute;
            right: 0;
            top: 20%;
        }

        /* Screens */
        #start-screen, #game-over-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
            padding: 20px;
            padding-bottom: env(safe-area-inset-bottom, 20px);
            overflow-y: auto;
            pointer-events: auto;
        }
        
        /* Short Screen Adaptation (Landscape Mobile) */
        @media (max-height: 500px) {
            #start-screen, #game-over-screen {
                flex-direction: row;
                justify-content: center;
                align-items: center;
                padding: 10px;
                gap: 30px;
            }
            
            #start-screen h1, #game-over-screen h1 {
                font-size: 28px;
                margin-bottom: 0;
                text-align: right;
                border-right: 2px solid #e91e63;
                padding-right: 30px;
            }
            
            .screen-content {
                display: flex;
                flex-direction: column;
                align-items: flex-start;
                text-align: left;
            }
            
            .modal-text {
                text-align: left;
                margin-bottom: 10px;
                font-size: 14px;
            }

            .btn {
                margin-top: 5px;
                padding: 10px 30px;
                font-size: 16px;
            }

            .score-display {
                font-size: 32px;
                margin: 0;
            }

            /* Make controls smaller on short screens */
            #controls {
                height: 0; /* Overlay style */
                overflow: visible;
                background: transparent;
                padding: 0;
            }
            
            .control-zone {
                position: absolute;
                bottom: 20px;
                width: 120px;
                height: 80px;
                background: rgba(255, 255, 255, 0.05); /* Faint background */
                border: none;
                border-radius: 20px;
                display: flex;
                align-items: center;
                justify-content: center;
                flex: none; /* Disable flex grow */
            }

            #btn-dodge {
                left: 20px;
                background: rgba(33, 150, 243, 0.1); /* Very faint Blue tint */
            }
            
            #btn-attack {
                right: 20px;
                background: rgba(233, 30, 99, 0.1); /* Very faint Pink tint */
            }

            .control-divider {
                display: none;
            }

            .control-label {
                font-size: 14px;
                color: #fff;
                text-shadow: 0 1px 2px rgba(0,0,0,0.8);
            }
        }

        #start-screen h1, #game-over-screen h1 {
            color: #fce4ec;
            font-size: 32px;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #e91e63;
            text-align: center;
        }

        .btn {
            background: linear-gradient(to bottom, #e91e63, #c2185b);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 18px;
            border-radius: 50px;
            cursor: pointer;
            margin-top: 20px;
            box-shadow: 0 5px 15px rgba(233, 30, 99, 0.4);
            font-weight: bold;
            text-transform: uppercase;
            pointer-events: auto;
        }
        
        .btn:active {
            transform: scale(0.95);
        }

        .modal-text {
            color: #ddd;
            font-size: 16px;
            line-height: 1.6;
            text-align: center;
            max-width: 300px;
            margin-bottom: 20px;
        }
        
        .score-display {
            font-size: 48px;
            color: #e91e63;
            font-weight: bold;
            margin: 10px 0;
        }

    </style>
</head>
<body>

<canvas id="canvas"></canvas>

<div id="ui-layer">
    <div id="top-hud">
        <div id="lives-panel"></div>
        <div id="score-container">
            <div id="score">0</div>
            <div id="best-score">BEST: 0</div>
        </div>
    </div>
    
    <div id="controls">
        <div class="control-zone" id="btn-dodge">
            <div class="control-label"></div> <!-- Text Removed -->
            <div class="control-divider"></div>
        </div>
        <div class="control-zone" id="btn-attack">
            <div class="control-label"></div> <!-- Text Removed -->
        </div>
    </div>
</div>

<div id="start-screen">
    <h1>忍者突袭</h1>
    <div class="screen-content">
        <div class="modal-text">
            敌人从上方来袭！<br><br>
            <span style="color:#e91e63">RIGHT</span> - 投掷飞镖<br>
            <span style="color:#2196f3">LEFT</span> - 闪避攻击
        </div>
        <button class="btn" id="start-btn">开始任务</button>
    </div>
</div>

<div id="game-over-screen" style="display: none;">
    <h1>任务结束</h1>
    <div class="screen-content">
        <div class="modal-text">最终得分</div>
        <div class="score-display" id="final-score">0</div>
        <div class="modal-text" id="final-best">最高分: 0</div>
        <button class="btn" id="restart-btn">再次挑战</button>
    </div>
</div>

<script>
    // 资源管理
    const assets = {
        bg: new Image(),
        ninja: new Image(),
        samurai: new Image(),
        shuriken: new Image(),
        gib: new Image()
    };
    
    assets.bg.src = './images/bg.svg';
    assets.ninja.src = './images/ninja.svg';
    assets.samurai.src = './images/samurai.svg';
    assets.shuriken.src = './images/shuriken.svg';
    assets.gib.src = './images/gib.svg';

    // 游戏配置
    const CONFIG = {
        gravity: 0.1,
        shurikenSpeed: 30,
        enemySpeedBase: 1.5,
        enemySpeedMax: 6,
        spawnRateBase: 40,
        dodgeDuration: 30,
        colors: {
            bg: '#1d1d1d',
            ninja: '#e91e63',
            enemy: '#5C6BC0',
            shuriken: '#fff'
        }
    };

    // 游戏状态
    const state = {
        playing: false,
        width: 0,
        height: 0,
        score: 0,
        bgY: 0,
        bestScore: parseInt(localStorage.getItem('ninja_best_score') || '0'),
        lives: 3,
        frameCount: 0,
        
        ninja: {
            x: 0, y: 0,
            width: 32, height: 32,
            dodging: 0,
        },
        
        enemies: [],
        projectiles: [],
        particles: []
    };

    // DOM元素
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const livesPanel = document.getElementById('lives-panel');
    const scoreEl = document.getElementById('score');
    const bestScoreEl = document.getElementById('best-score');
    const startScreen = document.getElementById('start-screen');
    const gameOverScreen = document.getElementById('game-over-screen');
    const finalScoreEl = document.getElementById('final-score');
    const finalBestEl = document.getElementById('final-best');

    // 初始化和调整画布大小
    function resize() {
        state.width = document.documentElement.clientWidth;
        state.height = document.documentElement.clientHeight;
        canvas.width = state.width;
        canvas.height = state.height;
        
        let defenseY;
        
        if (state.height < 500) {
           defenseY = state.height - 80; 
        } else {
           defenseY = state.height - 200;
        }

        state.defenseLine = defenseY;
        state.ninja.y = state.defenseLine;

        if (!state.playing) {
            state.ninja.x = state.width / 2;
            state.ninja.targetX = state.ninja.x;
        }
        
        bestScoreEl.innerText = `${state.bestScore}`;
    }

    // 开始游戏
    function startGame() {
        resize();
        state.playing = true;
        state.score = 0;
        state.lives = 3;
        state.frameCount = 0;
        state.bgY = 0;
        state.enemies = [];
        state.projectiles = [];
        state.particles = [];
        
        state.ninja.x = state.width / 2;
        state.ninja.y = state.defenseLine;
        state.ninja.targetX = state.width / 2;
        state.ninja.dodging = 0;
        
        updateUI();
        startScreen.style.display = 'none';
        gameOverScreen.style.display = 'none';
        
        gameLoop();
    }

    // 生成敌人
    function spawnEnemy() {
        const laneCount = 4;
        const laneIndex = Math.floor(Math.random() * laneCount);
        const laneWidth = state.width / laneCount;
        const x = (laneIndex * laneWidth) + (laneWidth / 2);
        
        const difficulty = Math.min(20, Math.floor(state.score / 50)); 
        const speed = CONFIG.enemySpeedBase + (difficulty * 0.3);
        
        state.enemies.push({
            x: x,
            y: -60,
            width: 36,
            height: 36,
            vy: speed,
            hp: 1 + Math.floor(difficulty / 5)
        });
    }

    // 创建爆炸效果
    function createExplosion(x, y, color) {
        for (let i = 0; i < 8; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 5 + 2;
            state.particles.push({
                x: x, y: y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                life: 30,
                color: color,
                image: assets.gib.complete && assets.gib.naturalWidth > 0 ? assets.gib : null
            });
        }
    }

    // 攻击
    function attack() {
        if (!state.playing) return;
        
        // 寻找最近的敌人
        let nearest = null;
        let minDist = Infinity;
        
        state.enemies.forEach(e => {
            if (e.y > -50 && e.y < state.ninja.y) {
                const dx = e.x - state.ninja.x;
                const dy = e.y - state.ninja.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < minDist) {
                    minDist = dist;
                    nearest = e;
                }
            }
        });

        const startX = state.ninja.x;
        const startY = state.ninja.y - 20;

        let vx = 0;
        let vy = -CONFIG.shurikenSpeed;

        if (nearest) {
            const dx = nearest.x - startX;
            const dy = nearest.y - startY;
            const angle = Math.atan2(dy, dx);
            vx = Math.cos(angle) * CONFIG.shurikenSpeed;
            vy = Math.sin(angle) * CONFIG.shurikenSpeed;
        }

        state.projectiles.push({
            x: startX,
            y: startY,
            vx: vx,
            vy: vy,
            width: 24, 
            height: 24,
            rotation: 0,
            target: nearest
        });
    }

    // 闪避
    function dodge() {
        if (!state.playing) return;
        if (state.ninja.dodging > 0) return;
        
        state.ninja.dodging = CONFIG.dodgeDuration;
        
        const dashDist = 120;
        const dir = Math.random() > 0.5 ? 1 : -1;
        
        let target = state.ninja.x + dir * dashDist;
        if (target < 40) target = state.ninja.x + dashDist;
        if (target > state.width - 40) target = state.ninja.x - dashDist;
        
        state.ninja.targetX = target;
    }

    // 更新游戏状态
    function update() {
        state.frameCount++;
        
        // 忍者移动
        if (Math.abs(state.ninja.targetX - state.ninja.x) > 1) {
            state.ninja.x += (state.ninja.targetX - state.ninja.x) * 0.2;
        } else {
             if (state.ninja.dodging === 0) {
                 state.ninja.targetX = state.width / 2;
             }
        }

        if (state.ninja.dodging > 0) state.ninja.dodging--;

        // 生成敌人
        const spawnParams = Math.max(20, CONFIG.spawnRateBase - Math.floor(state.score / 50));
        if (state.frameCount % spawnParams === 0) {
            spawnEnemy();
        }

        // 更新飞镖
        for (let i = state.projectiles.length - 1; i >= 0; i--) {
            const p = state.projectiles[i];
            
            // 追踪逻辑
            if (p.target && state.enemies.includes(p.target)) {
                 const dx = p.target.x - p.x;
                 const dy = p.target.y - p.y;
                 const targetAngle = Math.atan2(dy, dx);
                 const currentAngle = Math.atan2(p.vy, p.vx);
                 
                 let diff = targetAngle - currentAngle;
                 while (diff > Math.PI) diff -= Math.PI * 2;
                 while (diff < -Math.PI) diff += Math.PI * 2;
                 
                 const turnSpeed = 0.05; 
                 const turn = Math.max(-turnSpeed, Math.min(turnSpeed, diff));
                 
                 const newAngle = currentAngle + turn;
                 p.vx = Math.cos(newAngle) * CONFIG.shurikenSpeed;
                 p.vy = Math.sin(newAngle) * CONFIG.shurikenSpeed;
            }

            p.x += p.vx;
            p.y += p.vy;
            p.rotation += 0.5;

            if (p.x < 0 || p.x > state.width || p.y < 0 || p.y > state.height) {
                state.projectiles.splice(i, 1);
                continue;
            }

            // 检测命中敌人
            for (let j = state.enemies.length - 1; j >= 0; j--) {
                const e = state.enemies[j];
                const dx = p.x - e.x;
                const dy = p.y - e.y;
                if (Math.hypot(dx, dy) < 40) {
                    createExplosion(e.x, e.y, CONFIG.colors.enemy);
                    state.enemies.splice(j, 1);
                    state.projectiles.splice(i, 1);
                    state.score += 10;
                    updateUI();
                    break;
                }
            }
        }

        // 更新敌人
        for (let i = state.enemies.length - 1; i >= 0; i--) {
            const e = state.enemies[i];
            e.y += e.vy;

            const dist = Math.hypot(e.x - state.ninja.x, e.y - state.ninja.y);
            if (dist < 32) {
                if (state.ninja.dodging > 0) {
                    // 闪避成功
                } else {
                    createExplosion(e.x, e.y, '#ff0000');
                    state.enemies.splice(i, 1);
                    loseLife();
                    continue;
                }
            }

            if (e.y > state.height - 50) {
                state.enemies.splice(i, 1);
                loseLife();
            }
        }

        // 更新粒子
        for (let i = state.particles.length - 1; i >= 0; i--) {
            const p = state.particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life--;
            if (p.life <= 0) state.particles.splice(i, 1);
        }
    }

    // 失去生命
    function loseLife() {
        state.lives--;
        updateUI();
        const intense = 10;
        canvas.style.transform = `translate(${Math.random()*intense-intense/2}px, ${Math.random()*intense-intense/2}px)`;
        setTimeout(() => canvas.style.transform = 'none', 100);

        if (state.lives <= 0) {
            gameOver();
        }
    }

    // 更新UI
    function updateUI() {
        scoreEl.innerText = state.score;
        livesPanel.innerHTML = '';
        for (let i = 0; i < state.lives; i++) {
            const h = document.createElement('div');
            h.className = 'heart';
            h.innerText = '♥';
            livesPanel.appendChild(h);
        }
    }

    // 游戏结束
    function gameOver() {
        state.playing = false;
        if (state.score > state.bestScore) {
            state.bestScore = state.score;
            localStorage.setItem('ninja_best_score', state.bestScore);
        }
        finalScoreEl.innerText = state.score;
        finalBestEl.innerText = '最高' + state.bestScore;
        gameOverScreen.style.display = 'flex';
    }

    // 绘制游戏画面
    function draw() {
        ctx.fillStyle = CONFIG.colors.bg;
        ctx.fillRect(0, 0, state.width, state.height);
        
        if (assets.bg.complete) {
              ctx.drawImage(assets.bg, 0, 0, state.width, state.height);
              ctx.fillStyle = 'rgba(0,0,0,0.5)';
              ctx.fillRect(0,0,state.width, state.height);
        }

        // 绘制泳道线
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        for (let i = 1; i < 4; i++) {
            const lx = (state.width / 4) * i;
            ctx.moveTo(lx, 0);
            ctx.lineTo(lx, state.height);
        }
        ctx.stroke();

        // 绘制飞镖
        state.projectiles.forEach(p => {
             ctx.save();
             ctx.translate(p.x, p.y);
             ctx.rotate(p.rotation);
             if (assets.shuriken.complete) {
                 const size = 24;
                 ctx.drawImage(assets.shuriken, -size/2, -size/2, size, size);
             } else {
                 ctx.fillStyle = CONFIG.colors.shuriken;
                 ctx.beginPath();
                 ctx.arc(0, 0, 8, 0, Math.PI*2);
                 ctx.fill();
             }
             ctx.restore();
        });

        // 绘制忍者
        if (state.ninja.dodging > 0) {
            ctx.globalAlpha = 0.5;
        }
        
        const n = state.ninja;
        if (assets.ninja.complete && assets.ninja.naturalWidth > 0) {
            ctx.drawImage(
                assets.ninja, 
                n.x - n.width/2, n.y - n.height/2, n.width, n.height
            );
        } else {
            ctx.fillStyle = CONFIG.colors.ninja;
            ctx.beginPath();
            ctx.arc(n.x, n.y, n.width/2, 0, Math.PI*2);
            ctx.fill();
        }
        ctx.globalAlpha = 1.0;

        // 绘制敌人
        state.enemies.forEach(e => {
            if (assets.samurai.complete && assets.samurai.naturalWidth > 0) {
                 ctx.drawImage(
                    assets.samurai, 
                    e.x - e.width/2, e.y - e.height/2, e.width, e.height
                 );
            } else {
                ctx.fillStyle = CONFIG.colors.enemy;
                ctx.fillRect(e.x - e.width/2, e.y - e.height/2, e.width, e.height);
            }
        });
        
        // 绘制粒子效果
        state.particles.forEach(p => {
            if (p.image && p.image.complete) {
                ctx.save();
                ctx.translate(p.x, p.y);
                const size = 20 * (p.life / 30);
                ctx.drawImage(p.image, 0, 0, p.image.naturalWidth, p.image.naturalHeight, -size/2, -size/2, size, size);
                ctx.restore();
            } else {
                ctx.globalAlpha = p.life / 30;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.life/5, 0, Math.PI*2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        });
    }

    let lastTime = 0;
    const fpsInterval = 1000 / 60; 

    // 游戏主循环
    function gameLoop(timestamp) {
        if (!state.playing) return;
        
        if (!lastTime) lastTime = timestamp;
        const elapsed = timestamp - lastTime;

        if (elapsed > fpsInterval) {
            lastTime = timestamp - (elapsed % fpsInterval);
            update();
            draw();
        }
        requestAnimationFrame(gameLoop);
    }

    // 输入处理
    const btnAttack = document.getElementById('btn-attack');
    const btnDodge = document.getElementById('btn-dodge');
    const btnStart = document.getElementById('start-btn');
    const btnRestart = document.getElementById('restart-btn');

    const handleAttack = (e) => { 
        e.preventDefault(); 
        if(e.type === 'mousedown' && 'ontouchstart' in window) return;
        attack(); 
    };
    const handleDodge = (e) => { 
        e.preventDefault(); 
        if(e.type === 'mousedown' && 'ontouchstart' in window) return;
        dodge(); 
    };

    btnAttack.addEventListener('touchstart', handleAttack, {passive: false});
    btnAttack.addEventListener('mousedown', handleAttack);
    
    btnDodge.addEventListener('touchstart', handleDodge, {passive: false});
    btnDodge.addEventListener('mousedown', handleDodge);

    document.addEventListener('keydown', (e) => {
        if (!state.playing) return;
        if (e.code === 'ArrowRight' || e.code === 'KeyD') attack();
        if (e.code === 'ArrowLeft' || e.code === 'KeyL' || e.code === 'KeyA') dodge();
    });

    btnStart.addEventListener('click', startGame);
    btnRestart.addEventListener('click', startGame);

    window.addEventListener('resize', resize);
    
    resize();
    ctx.fillStyle = CONFIG.colors.bg;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

</script>
</body>
</html>
