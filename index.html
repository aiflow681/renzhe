<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>忍者突袭 Pure H5</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        html {
            height: 100%;
        }

        body {
            overflow: hidden;
            background-color: #1d1d1d;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            touch-action: none;
            height: 100%;
            width: 100%;
            position: fixed; /* Prevents scroll bounce on mobile */
        }

        #canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        #top-hud {
            width: 100%;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        #lives-panel {
            display: flex;
            gap: 5px;
        }
        
        .heart {
            color: #ff1744;
            font-size: 24px;
            text-shadow: 0 0 5px rgba(255, 23, 68, 0.5);
        }

        #score-container {
            text-align: right;
        }

        #score {
            font-size: 36px;
            color: #fff;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        
        #best-score {
            font-size: 14px;
            color: #aaa;
            margin-top: 5px;
        }

        /* Controls */
        #controls {
            width: 100%;
            height: 160px; /* Fixed height for controls */
            display: flex;
            pointer-events: auto; /* Enable clicks */
            position: absolute;
            bottom: 0;
            left: 0;
            padding-bottom: env(safe-area-inset-bottom, 20px);
        }

        .control-zone {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            border-top: 1px solid rgba(255,255,255,0.1);
            background: rgba(0,0,0,0.2);
            position: relative;
        }
        
        .control-zone:active {
            background: rgba(255,255,255,0.05); /* Visual feedback */
        }

        .control-label {
            font-size: 24px;
            color: rgba(255,255,255,0.5);
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            pointer-events: none;
        }
        
        .control-divider {
            width: 1px;
            height: 60%;
            background: rgba(255,255,255,0.1);
            position: absolute;
            right: 0;
            top: 20%;
        }

        /* Screens */
        #start-screen, #game-over-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
            padding: 20px;
            padding-bottom: env(safe-area-inset-bottom, 20px);
            overflow-y: auto;
        }
        
        /* Short Screen Adaptation (Landscape Mobile) */
        @media (max-height: 500px) {
            #start-screen, #game-over-screen {
                flex-direction: row;
                justify-content: center;
                align-items: center;
                padding: 10px;
                gap: 30px;
            }
            
            #start-screen h1, #game-over-screen h1 {
                font-size: 28px;
                margin-bottom: 0;
                text-align: right;
                border-right: 2px solid #e91e63;
                padding-right: 30px;
            }
            
            .screen-content {
                display: flex;
                flex-direction: column;
                align-items: flex-start;
                text-align: left;
            }
            
            .modal-text {
                text-align: left;
                margin-bottom: 10px;
                font-size: 14px;
            }

            .btn {
                margin-top: 5px;
                padding: 10px 30px;
                font-size: 16px;
            }

            .score-display {
                font-size: 32px;
                margin: 0;
            }

            /* Make controls smaller on short screens */
            #controls {
                height: 0; /* Overlay style */
                overflow: visible;
                background: transparent;
                padding: 0;
            }
            
            .control-zone {
                position: absolute;
                bottom: 20px;
                width: 120px;
                height: 80px;
                background: rgba(255, 255, 255, 0.05); /* Faint background */
                border: none;
                border-radius: 20px;
                display: flex;
                align-items: center;
                justify-content: center;
                flex: none; /* Disable flex grow */
            }

            #btn-dodge {
                left: 20px;
                background: rgba(33, 150, 243, 0.1); /* Very faint Blue tint */
            }
            
            #btn-attack {
                right: 20px;
                background: rgba(233, 30, 99, 0.1); /* Very faint Pink tint */
            }

            .control-divider {
                display: none;
            }

            .control-label {
                font-size: 14px;
                color: #fff;
                text-shadow: 0 1px 2px rgba(0,0,0,0.8);
            }
        }

        #start-screen h1, #game-over-screen h1 {
            color: #fce4ec;
            font-size: 32px;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #e91e63;
            text-align: center;
        }

        .btn {
            background: linear-gradient(to bottom, #e91e63, #c2185b);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 18px;
            border-radius: 50px;
            cursor: pointer;
            margin-top: 20px;
            box-shadow: 0 5px 15px rgba(233, 30, 99, 0.4);
            font-weight: bold;
            text-transform: uppercase;
        }
        
        .btn:active {
            transform: scale(0.95);
        }

        .modal-text {
            color: #ddd;
            font-size: 16px;
            line-height: 1.6;
            text-align: center;
            max-width: 300px;
            margin-bottom: 20px;
        }
        
        .score-display {
            font-size: 48px;
            color: #e91e63;
            font-weight: bold;
            margin: 10px 0;
        }

    </style>
</head>
<body>

<canvas id="canvas"></canvas>

<div id="ui-layer">
    <div id="top-hud">
        <div id="lives-panel"></div>
        <div id="score-container">
            <div id="score">0</div>
            <div id="best-score">BEST: 0</div>
        </div>
    </div>
    
    <div id="controls">
        <div class="control-zone" id="btn-dodge">
            <div class="control-label"></div> <!-- Text Removed -->
            <div class="control-divider"></div>
        </div>
        <div class="control-zone" id="btn-attack">
            <div class="control-label"></div> <!-- Text Removed -->
        </div>
    </div>
</div>

<div id="start-screen">
    <h1>忍者突袭</h1>
    <div class="screen-content">
        <div class="modal-text">
            敌人从上方来袭！<br><br>
            <span style="color:#e91e63">RIGHT</span> - 投掷飞镖<br>
            <span style="color:#2196f3">LEFT</span> - 闪避攻击
        </div>
        <button class="btn" id="start-btn">开始任务</button>
    </div>
</div>

<div id="game-over-screen" style="display: none;">
    <h1>任务结束</h1>
    <div class="screen-content">
        <div class="modal-text">最终得分</div>
        <div class="score-display" id="final-score">0</div>
        <div class="modal-text" id="final-best">最高分: 0</div>
        <button class="btn" id="restart-btn">再次挑战</button>
    </div>
</div>

<script>
    // Asset Management
    const assets = {
        bg: new Image(),
        ninja: new Image(),
        samurai: new Image(),
        shuriken: new Image(),
        gib: new Image()
    };
    
    assets.bg.src = './images/bg.png';
    assets.ninja.src = './images/ninja.png';
    assets.samurai.src = './images/samurai.png';
    assets.shuriken.src = './images/shuriken.png';
    assets.gib.src = './images/gib.png';

    // Constants
    const CONFIG = {
        gravity: 0.1,
        shurikenSpeed: 30, // Faster projectiles for easier accuracy
        enemySpeedBase: 1.5, // Even slower base speed
        enemySpeedMax: 6,  // Lower max cap
        spawnRateBase: 40, // Faster spawn rate (More often)
        dodgeDuration: 30, // frames
        colors: {
            bg: '#1d1d1d',
            ninja: '#e91e63',
            enemy: '#5C6BC0',
            shuriken: '#fff'
        }
    };

    // State
    const state = {
        playing: false,
        width: 0,
        height: 0,
        score: 0,
        bgY: 0, // Background scroll
        bestScore: parseInt(localStorage.getItem('ninja_best_score') || '0'),
        lives: 3,
        frameCount: 0,
        
        ninja: {
            x: 0, y: 0,
            width: 32, height: 32, // Smaller Ninja
            dodging: 0, // timer
        },
        
        enemies: [], // {x, y, vy, ...}
        projectiles: [], // {x, y, vx, vy, ...}
        particles: []
    };

    // Elements
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const livesPanel = document.getElementById('lives-panel');
    const scoreEl = document.getElementById('score');
    const bestScoreEl = document.getElementById('best-score');
    const startScreen = document.getElementById('start-screen');
    const gameOverScreen = document.getElementById('game-over-screen');
    const finalScoreEl = document.getElementById('final-score');
    const finalBestEl = document.getElementById('final-best');

    // Init
    function resize() {
        state.width = document.documentElement.clientWidth;
        state.height = document.documentElement.clientHeight;
        canvas.width = state.width;
        canvas.height = state.height;
        
        // Calculate Defense Line based on screen height
        let defenseY;
        
        if (state.height < 500) {
           // Landscape / Short screen:
           // Controls are on sides, so we can use more bottom space.
           // Buttons occupy ~100px height at bottom sides.
           // Ninja is in center, so he can go lower.
           defenseY = state.height - 80; 
        } else {
           // Portrait: Controls are a bottom bar (160px) + padding
           defenseY = state.height - 200;
        }

        state.defenseLine = defenseY;
        
        // Update Ninja Y
        state.ninja.y = state.defenseLine;

        if (!state.playing) {
            state.ninja.x = state.width / 2;
            state.ninja.targetX = state.ninja.x;
        }
        
        bestScoreEl.innerText = `${state.bestScore}`; // Removed 'BEST' text
    }

    function startGame() {
        resize(); // Ensure defense line is set correctly
        state.playing = true;
        state.score = 0;
        state.lives = 3;
        state.frameCount = 0;
        state.bgY = 0;
        state.enemies = [];
        state.projectiles = [];
        state.particles = [];
        
        state.ninja.x = state.width / 2;
        state.ninja.y = state.defenseLine;
        state.ninja.targetX = state.width / 2;
        state.ninja.dodging = 0;
        
        updateUI();
        startScreen.style.display = 'none';
        gameOverScreen.style.display = 'none';
        
        gameLoop();
    }

    function spawnEnemy() {
        // 4 Lanes Logic to mimic Castle Defense style
        const laneCount = 4;
        const laneIndex = Math.floor(Math.random() * laneCount);
        const laneWidth = state.width / laneCount;
        const x = (laneIndex * laneWidth) + (laneWidth / 2);
        
        // Difficulty scaling
        const difficulty = Math.min(20, Math.floor(state.score / 50)); 
        const speed = CONFIG.enemySpeedBase + (difficulty * 0.3); // Slower interval
        
        state.enemies.push({
            x: x,
            y: -60,
            width: 36, // Smaller Enemy
            height: 36, // Smaller Enemy
            vy: speed,
            hp: 1 + Math.floor(difficulty / 5) // HP increases gradually
        });
    }

    function createExplosion(x, y, color) {
        for (let i = 0; i < 8; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 5 + 2;
            state.particles.push({
                x: x, y: y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                life: 30,
                color: color,
                image: assets.gib.complete && assets.gib.naturalWidth > 0 ? assets.gib : null
            });
        }
    }

    function attack() {
        if (!state.playing) return;
        
        // Find nearest enemy
        let nearest = null;
        let minDist = Infinity;
        
        state.enemies.forEach(e => {
            if (e.y > -50 && e.y < state.ninja.y) {
                const dx = e.x - state.ninja.x;
                const dy = e.y - state.ninja.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < minDist) {
                    minDist = dist;
                    nearest = e;
                }
            }
        });

        const startX = state.ninja.x;
        const startY = state.ninja.y - 20;

        let vx = 0;
        let vy = -CONFIG.shurikenSpeed;

        if (nearest) {
            // Homing Missile Setup
            // We set the initial velocity, but we also save the target.
            // In update(), we will steer the projectile towards this target.
            const dx = nearest.x - startX;
            const dy = nearest.y - startY;
            const angle = Math.atan2(dy, dx);
            vx = Math.cos(angle) * CONFIG.shurikenSpeed;
            vy = Math.sin(angle) * CONFIG.shurikenSpeed;
        }

        state.projectiles.push({
            x: startX,
            y: startY,
            vx: vx,
            vy: vy,
            width: 24, 
            height: 24,
            rotation: 0,
            target: nearest // LOCK-ON
        });
    }

    function dodge() {
        if (!state.playing) return;
        if (state.ninja.dodging > 0) return; // Cooldown?
        
        state.ninja.dodging = CONFIG.dodgeDuration;
        
        // Visual effect / Dash
        // Move randomly left or right to simulate dodge
        const dashDist = 120;
        const dir = Math.random() > 0.5 ? 1 : -1;
        
        let target = state.ninja.x + dir * dashDist;
        // Keep in bounds
        if (target < 40) target = state.ninja.x + dashDist; // force right if hitting left wall
        if (target > state.width - 40) target = state.ninja.x - dashDist; // force left if hitting right wall
        
        state.ninja.targetX = target; // Smooth move handled in update
    }

    function update() {
        state.frameCount++;
        
        // Smooth Ninja Move (Dodge behavior)
        if (Math.abs(state.ninja.targetX - state.ninja.x) > 1) {
            state.ninja.x += (state.ninja.targetX - state.ninja.x) * 0.2;
        } else {
             // Return to center slowly? Or stay? Stay is chaos.
             // Usually these games have fixed lanes or positions.
             // Let's make him return to center if not dodging
             if (state.ninja.dodging === 0) {
                 state.ninja.targetX = state.width / 2;
             }
        }

        // Ninja Dodge timer
        if (state.ninja.dodging > 0) state.ninja.dodging--;

        // Spawn
        const spawnParams = Math.max(20, CONFIG.spawnRateBase - Math.floor(state.score / 50));
        if (state.frameCount % spawnParams === 0) {
            spawnEnemy();
        }

        // Update Projectiles
        for (let i = state.projectiles.length - 1; i >= 0; i--) {
            const p = state.projectiles[i];
            
            // HOMING LOGIC (Reduced Accuracy)
            if (p.target && state.enemies.includes(p.target)) {
                 const dx = p.target.x - p.x;
                 const dy = p.target.y - p.y;
                 const targetAngle = Math.atan2(dy, dx);
                 const currentAngle = Math.atan2(p.vy, p.vx);
                 
                 // Steering: Blend angles with a limit
                 let diff = targetAngle - currentAngle;
                 // Normalize angle diff to -PI to PI
                 while (diff > Math.PI) diff -= Math.PI * 2;
                 while (diff < -Math.PI) diff += Math.PI * 2;
                 
                 // Turn speed limit (The "Accuracy" Factor)
                 // Lower = Less accurate/Slower turn
                 const turnSpeed = 0.05; 
                 const turn = Math.max(-turnSpeed, Math.min(turnSpeed, diff));
                 
                 const newAngle = currentAngle + turn;
                 p.vx = Math.cos(newAngle) * CONFIG.shurikenSpeed;
                 p.vy = Math.sin(newAngle) * CONFIG.shurikenSpeed;
            }

            p.x += p.vx;
            p.y += p.vy;
            p.rotation += 0.5;

            // Bounds
            if (p.x < 0 || p.x > state.width || p.y < 0 || p.y > state.height) {
                state.projectiles.splice(i, 1);
                continue;
            }

            // Hit Enemy
            for (let j = state.enemies.length - 1; j >= 0; j--) {
                const e = state.enemies[j];
                const dx = p.x - e.x;
                const dy = p.y - e.y;
                if (Math.hypot(dx, dy) < 40) { // Large benevolent hitbox
                    // Hit!
                    createExplosion(e.x, e.y, CONFIG.colors.enemy);
                    state.enemies.splice(j, 1);
                    state.projectiles.splice(i, 1);
                    state.score += 10;
                    updateUI();
                    break;
                }
            }
        }

        // Update Enemies
        for (let i = state.enemies.length - 1; i >= 0; i--) {
            const e = state.enemies[i];
            e.y += e.vy;

            // Check Player Collision
            const dist = Math.hypot(e.x - state.ninja.x, e.y - state.ninja.y);
            if (dist < 32) { // Adjusted player impact radius
                // If dodging, safe!
                if (state.ninja.dodging > 0) {
                    // Safe pass
                } else {
                    // Hit!
                    createExplosion(e.x, e.y, '#ff0000');
                    state.enemies.splice(i, 1);
                    loseLife();
                    continue;
                }
            }

            // Check Bottom
            // If enemy reaches defense line (control area)
            // Allow them to fall a bit lower, near the bottom of screen, to give player more time
            // since controls are now faint/overlay.
            if (e.y > state.height - 50) {
                state.enemies.splice(i, 1);
                loseLife();
            }
        }

        // Particles
        for (let i = state.particles.length - 1; i >= 0; i--) {
            const p = state.particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life--;
            if (p.life <= 0) state.particles.splice(i, 1);
        }
    }

    function loseLife() {
        state.lives--;
        updateUI();
        // Shake effect
        const intense = 10;
        canvas.style.transform = `translate(${Math.random()*intense-intense/2}px, ${Math.random()*intense-intense/2}px)`;
        setTimeout(() => canvas.style.transform = 'none', 100);

        if (state.lives <= 0) {
            gameOver();
        }
    }

    function updateUI() {
        scoreEl.innerText = state.score;
        livesPanel.innerHTML = '';
        for (let i = 0; i < state.lives; i++) {
            const h = document.createElement('div');
            h.className = 'heart';
            h.innerText = '♥';
            livesPanel.appendChild(h);
        }
    }

    function gameOver() {
        state.playing = false;
        if (state.score > state.bestScore) {
            state.bestScore = state.score;
            localStorage.setItem('ninja_best_score', state.bestScore);
        }
        finalScoreEl.innerText = state.score;
        finalBestEl.innerText = '最高' + state.bestScore; // Removed English
        gameOverScreen.style.display = 'flex';
    }

    function draw() {
        ctx.fillStyle = CONFIG.colors.bg;
        ctx.fillRect(0, 0, state.width, state.height);
        
        if (assets.bg.complete) {
              ctx.drawImage(assets.bg, 0, 0, state.width, state.height);
              ctx.fillStyle = 'rgba(0,0,0,0.5)';
              ctx.fillRect(0,0,state.width, state.height);
        }

        // Draw Lanes
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)'; // More faint
        ctx.lineWidth = 1;
        ctx.beginPath();
        for (let i = 1; i < 4; i++) {
            const lx = (state.width / 4) * i;
            ctx.moveTo(lx, 0);
            ctx.lineTo(lx, state.height);
        }
        ctx.stroke();

        // Projectiles (Draw first)
        state.projectiles.forEach(p => {
             ctx.save();
             ctx.translate(p.x, p.y);
             ctx.rotate(p.rotation);
             if (assets.shuriken.complete) {
                 const size = 24; // Smaller shuriken
                 ctx.drawImage(assets.shuriken, -size/2, -size/2, size, size);
             } else {
                 ctx.fillStyle = CONFIG.colors.shuriken;
                 ctx.beginPath();
                 ctx.arc(0, 0, 8, 0, Math.PI*2); // Smaller simple circle
                 ctx.fill();
             }
             ctx.restore();
        });

        // Ninja
        if (state.ninja.dodging > 0) {
            ctx.globalAlpha = 0.5; // Ghost mode
        }
        
        const n = state.ninja;
        if (assets.ninja.complete && assets.ninja.naturalWidth > 0) {
            // Adjusted: Width / 2 (2 columns), Height / 4 (4 rows) to display single character
            const frameW = assets.ninja.naturalWidth / 2; 
            const frameH = assets.ninja.naturalHeight / 4;
            
            ctx.drawImage(
                assets.ninja, 
                0, 0, frameW, frameH, // Source: Top Left
                n.x - n.width/2, n.y - n.height/2, n.width, n.height // Dest
            );
        } else {
            ctx.fillStyle = CONFIG.colors.ninja;
            ctx.beginPath();
            ctx.arc(n.x, n.y, n.width/2, 0, Math.PI*2);
            ctx.fill();
        }
        ctx.globalAlpha = 1.0;

        // Enemies
        state.enemies.forEach(e => {
            if (assets.samurai.complete && assets.samurai.naturalWidth > 0) {
                 const frameW = assets.samurai.naturalWidth / 2;
                 const frameH = assets.samurai.naturalHeight / 2;
                 
                 ctx.drawImage(
                    assets.samurai, 
                    0, 0, frameW, frameH, 
                    e.x - e.width/2, e.y - e.height/2, e.width, e.height
                 );
            } else {
                ctx.fillStyle = CONFIG.colors.enemy;
                ctx.fillRect(e.x - e.width/2, e.y - e.height/2, e.width, e.height);
            }
        });
        
        // Particles
        state.particles.forEach(p => {
            if (p.image && p.image.complete) {
                ctx.save();
                ctx.translate(p.x, p.y);
                const size = 20 * (p.life / 30);
                
                // Crop logic for gibs if needed, or just draw
                ctx.drawImage(p.image, 0, 0, p.image.naturalWidth, p.image.naturalHeight, -size/2, -size/2, size, size);
                ctx.restore();
            } else {
                ctx.globalAlpha = p.life / 30;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.life/5, 0, Math.PI*2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        });
    }

    let lastTime = 0;
    const fpsInterval = 1000 / 60; 

    function gameLoop(timestamp) {
        if (!state.playing) return;
        
        if (!lastTime) lastTime = timestamp;
        const elapsed = timestamp - lastTime;

        if (elapsed > fpsInterval) {
            lastTime = timestamp - (elapsed % fpsInterval);
            update();
            draw();
        }
        requestAnimationFrame(gameLoop);
    }

    // Input Handling
    const btnAttack = document.getElementById('btn-attack');
    const btnDodge = document.getElementById('btn-dodge');
    const btnStart = document.getElementById('start-btn');
    const btnRestart = document.getElementById('restart-btn');

    // Touch/Click
    const handleAttack = (e) => { 
        e.preventDefault(); 
        if(e.type === 'mousedown' && 'ontouchstart' in window) return; // Prevent double firing
        attack(); 
    };
    const handleDodge = (e) => { 
        e.preventDefault(); 
        if(e.type === 'mousedown' && 'ontouchstart' in window) return;
        dodge(); 
    };

    btnAttack.addEventListener('touchstart', handleAttack, {passive: false});
    btnAttack.addEventListener('mousedown', handleAttack);
    
    btnDodge.addEventListener('touchstart', handleDodge, {passive: false});
    btnDodge.addEventListener('mousedown', handleDodge);

    // Keyboard
    document.addEventListener('keydown', (e) => {
        if (!state.playing) return;
        if (e.code === 'ArrowRight' || e.code === 'KeyD') attack();
        if (e.code === 'ArrowLeft' || e.code === 'KeyL' || e.code === 'KeyA') dodge();
    });

    btnStart.addEventListener('click', startGame);
    btnRestart.addEventListener('click', startGame);

    window.addEventListener('resize', resize);
    
    // Initial draw
    resize();
    ctx.fillStyle = CONFIG.colors.bg;
    ctx.fillRect(0, 0, canvas.width, canvas.height); // Black screen before start

</script>
</body>
</html>
